macro_rules! index { ($arr: expr, $idx: expr) => { &$arr[$idx] }; } macro_rules! impossible { () => { unreachable!() }; }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum TokenKind { _Eps, _Eof, _Err, Add, Sub, Mul, Div, Mod, UNeg, UNot, UBNot, Else, Int, Return, If, For, Do, While, Break, Continue, Semi, Comma, LPar, RPar, LBrc, RBrc, LBkt, RBkt, Eq, Eqto, Colon, Quest, Neq, Geq, Gt, Leq, Lt, LOr, LAnd, And, IntConst, Id }

enum StackItem<'p> { _Token(Token<'p>), _0(Prog<'p>), _1(Type), _2(Func<'p>), _3(Vec<Declaration<'p>>), _4(Vec<BlockItem<'p>>), _5(BlockItem<'p>), _6(Stmt<'p>), _7(Option<Stmt<'p>>), _8(Option<Expr<'p>>), _9(Declaration<'p>), _10(Vec<usize>), _11(Expr<'p>), _12(Conditional<'p>), _13(LogicalOr<'p>), _14(LogicalAnd<'p>), _15(Equality<'p>), _16(Relational<'p>), _17(Additive<'p>), _18(Multiplicative<'p>), _19(Unary<'p>), _20(Primary<'p>), _21(Vec<Expr<'p>>) }

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub struct Token<'l> {
    pub kind: TokenKind,
    pub piece: &'l [u8],
    pub line: u32,
    pub col: u32,
}

pub struct Lexer<'l> {
    pub string: &'l [u8],
    pub line: u32,
    pub col: u32,
}

impl<'l> Lexer<'l> {
    pub fn new(string: &[u8]) -> Lexer {
        Lexer { string, line: 1, col: 1 }
    }

    pub fn next(&mut self) -> Token<'l> {
        static ACC: [TokenKind; 69] = [TokenKind::_Err, TokenKind::_Eps, TokenKind::UNot, TokenKind::Mod, TokenKind::And, TokenKind::LPar, TokenKind::RPar, TokenKind::Mul, TokenKind::Add, TokenKind::Comma, TokenKind::Sub, TokenKind::Div, TokenKind::IntConst, TokenKind::Colon, TokenKind::Semi, TokenKind::Lt, TokenKind::Eqto, TokenKind::Gt, TokenKind::Quest, TokenKind::Id, TokenKind::LBkt, TokenKind::RBkt, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::LBrc, TokenKind::_Err, TokenKind::RBrc, TokenKind::UBNot, TokenKind::Neq, TokenKind::LAnd, TokenKind::Leq, TokenKind::Eq, TokenKind::Geq, TokenKind::Id, TokenKind::Id, TokenKind::Do, TokenKind::Id, TokenKind::Id, TokenKind::If, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::LOr, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::For, TokenKind::Int, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Id, TokenKind::Else, TokenKind::Id, TokenKind::Id, TokenKind::Break, TokenKind::Id, TokenKind::Id, TokenKind::While, TokenKind::Id, TokenKind::Return, TokenKind::Id, TokenKind::Continue, ];
        static EC: [u8; 256] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 3, 4, 0, 5, 6, 7, 8, 9, 10, 0, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 14, 15, 16, 17, 18, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 0, 21, 0, 19, 0, 22, 23, 24, 25, 26, 27, 19, 28, 29, 19, 30, 31, 19, 32, 33, 19, 19, 34, 35, 36, 37, 19, 38, 19, 19, 19, 39, 40, 41, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ];
        static DFA_EDGE: [[u8; 43]; 69] = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 19, 22, 23, 24, 25, 26, 19, 27, 19, 19, 19, 19, 28, 19, 19, 19, 29, 30, 31, 32, 33, ], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 39, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 40, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 41, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 42, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 43, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 44, 19, 19, 19, 19, 45, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 46, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 47, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 49, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 50, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 51, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 52, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 53, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 54, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 55, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 56, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 57, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 58, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 59, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 60, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 61, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 62, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 63, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 64, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 65, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 66, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 67, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 68, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 19, 0, 0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 0, 0, 0, 0, ], ];
        // line & col is the beginning of this token, self.line & col is the latest char
        let (mut line, mut col) = (self.line, self.col);
        let mut last_acc = TokenKind::_Err;
        let mut state = 0;
        let mut i = 0;
        while i < self.string.len() {
            let ch = *index!(self.string, i);
            let ec = *index!(EC, ch as usize);
            let nxt = *index!(index!(DFA_EDGE, state), ec as usize);
            let acc = *index!(ACC, nxt as usize);
            if acc != TokenKind::_Err { last_acc = acc };
            state = nxt as usize;
            if nxt == 0 { // dead, should not eat this char
                let piece = index!(self.string, ..i);
                self.string = index!(self.string, i..);
                if last_acc != TokenKind::_Eps {
                    return Token { kind: last_acc, piece, line, col };
                } else {
                    line = self.line;
                    col = self.col;
                    last_acc = TokenKind::_Err;
                    state = 0;
                    i = 0;
                }
            } else { // continue, eat this char
                if ch == b'\n' {
                    self.line += 1;
                    self.col = 1;
                } else {
                    self.col += 1;
                }
                i += 1;
            }
        }
        // end of file
        let piece = index!(self.string, ..i);
        self.string = b"";
        if last_acc != TokenKind::_Eps && i != 0 { Token { kind: last_acc, piece, line, col } } else { Token { kind: TokenKind::_Eof, piece: b"", line: self.line, col: self.col } }
    }
}


impl<'p> Parser {
    pub fn parse<'l: 'p>(&mut self, lexer: &mut Lexer<'l>) -> Result<Prog<'p>, Token<'l>> {
        static PROD: [u8; 75] = [0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25, 26, ];
        static ACTION: [[u16; 42]; 148] = [[3, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 13, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 13, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 13, ], [3, 3, 3, 3, 3, 24, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 28, ], [3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 17, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 129, 3, 32, 3, 3, 3, 129, 3, 3, 36, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 37, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 29, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 128, 3, 3, 3, 3, 3, 132, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 136, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 269, 269, 269, 269, 269, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 269, 269, 3, 269, 3, 3, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 3, 3, 3, ], [3, 3, 3, 277, 277, 277, 277, 277, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 277, 277, 172, 277, 3, 3, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 176, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 137, 137, 3, 137, 3, 3, 3, 137, 3, 3, 137, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 145, 145, 3, 145, 3, 3, 3, 145, 3, 3, 145, 180, 3, 3, 3, 3, 3, 184, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 153, 153, 3, 153, 3, 3, 3, 153, 3, 3, 153, 153, 3, 3, 3, 3, 3, 153, 188, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 161, 161, 3, 161, 3, 3, 3, 161, 192, 3, 161, 161, 196, 3, 3, 3, 3, 161, 161, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 169, 169, 3, 169, 3, 3, 3, 169, 169, 3, 169, 169, 169, 200, 204, 208, 212, 169, 169, 3, 3, 3, ], [3, 3, 3, 216, 220, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 181, 181, 3, 181, 3, 3, 3, 181, 181, 3, 181, 181, 181, 181, 181, 181, 181, 181, 181, 3, 3, 3, ], [3, 3, 3, 201, 201, 224, 228, 232, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 201, 201, 3, 201, 3, 3, 3, 201, 201, 3, 201, 201, 201, 201, 201, 201, 201, 201, 201, 3, 3, 3, ], [3, 3, 3, 213, 213, 213, 213, 213, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 213, 213, 3, 213, 3, 3, 3, 213, 213, 236, 213, 213, 213, 213, 213, 213, 213, 213, 213, 3, 3, 3, ], [3, 3, 3, 229, 229, 229, 229, 229, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 229, 229, 3, 229, 3, 3, 240, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 229, 3, 3, 3, ], [3, 3, 3, 257, 257, 257, 257, 257, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 257, 257, 3, 257, 3, 3, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 3, 3, 3, ], [3, 121, 3, 3, 121, 121, 3, 3, 3, 121, 121, 3, 121, 121, 121, 121, 121, 121, 121, 121, 121, 3, 121, 3, 121, 121, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 121, 121, 121, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 244, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 248, 3, 3, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 24, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 260, ], [3, 3, 3, 233, 233, 233, 233, 233, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 233, 233, 3, 233, 3, 3, 3, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 3, 3, 3, ], [3, 3, 3, 245, 245, 245, 245, 245, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 245, 245, 3, 245, 3, 3, 3, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 245, 3, 3, 3, ], [3, 3, 3, 237, 237, 237, 237, 237, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 237, 237, 3, 237, 3, 3, 3, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 237, 3, 3, 3, ], [3, 3, 3, 241, 241, 241, 241, 241, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 241, 241, 3, 241, 3, 3, 3, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 3, 3, 3, ], [3, 3, 3, 3, 3, 24, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 264, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 268, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 249, 249, 249, 249, 249, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 249, 249, 3, 249, 3, 3, 3, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 3, 3, 3, ], [3, 3, 3, 3, 289, 289, 3, 3, 3, 289, 289, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 289, 281, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 289, 289, 289, ], [3, 125, 3, 3, 125, 125, 3, 3, 3, 125, 125, 3, 125, 125, 125, 125, 125, 125, 125, 125, 125, 3, 125, 3, 125, 125, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 125, 125, 125, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 348, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 25, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 49, 49, 3, 3, 3, 49, 49, 3, 49, 49, 49, 49, 49, 49, 49, 49, 49, 3, 49, 3, 49, 49, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 49, 49, 49, ], [3, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 356, 3, 33, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 273, 273, 273, 273, 273, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 273, 273, 3, 273, 3, 3, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 273, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 364, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 372, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 157, 157, 3, 157, 3, 3, 3, 157, 3, 3, 157, 157, 3, 3, 3, 3, 3, 157, 188, 3, 3, 3, ], [3, 3, 3, 213, 213, 213, 213, 213, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 213, 213, 3, 213, 3, 3, 3, 213, 213, 3, 213, 213, 213, 213, 213, 213, 213, 213, 213, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 165, 165, 3, 165, 3, 3, 3, 165, 192, 3, 165, 165, 196, 3, 3, 3, 3, 165, 165, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 173, 173, 3, 173, 3, 3, 3, 173, 173, 3, 173, 173, 173, 200, 204, 208, 212, 173, 173, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 177, 177, 3, 177, 3, 3, 3, 177, 177, 3, 177, 177, 177, 200, 204, 208, 212, 177, 177, 3, 3, 3, ], [3, 3, 3, 216, 220, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 185, 185, 3, 185, 3, 3, 3, 185, 185, 3, 185, 185, 185, 185, 185, 185, 185, 185, 185, 3, 3, 3, ], [3, 3, 3, 216, 220, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 193, 193, 3, 193, 3, 3, 3, 193, 193, 3, 193, 193, 193, 193, 193, 193, 193, 193, 193, 3, 3, 3, ], [3, 3, 3, 216, 220, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 189, 189, 3, 189, 3, 3, 3, 189, 189, 3, 189, 189, 189, 189, 189, 189, 189, 189, 189, 3, 3, 3, ], [3, 3, 3, 216, 220, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 197, 197, 3, 197, 3, 3, 3, 197, 197, 3, 197, 197, 197, 197, 197, 197, 197, 197, 197, 3, 3, 3, ], [3, 3, 3, 205, 205, 224, 228, 232, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 205, 205, 3, 205, 3, 3, 3, 205, 205, 3, 205, 205, 205, 205, 205, 205, 205, 205, 205, 3, 3, 3, ], [3, 3, 3, 209, 209, 224, 228, 232, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 209, 209, 3, 209, 3, 3, 3, 209, 209, 3, 209, 209, 209, 209, 209, 209, 209, 209, 209, 3, 3, 3, ], [3, 3, 3, 217, 217, 217, 217, 217, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 217, 217, 3, 217, 3, 3, 3, 217, 217, 3, 217, 217, 217, 217, 217, 217, 217, 217, 217, 3, 3, 3, ], [3, 3, 3, 221, 221, 221, 221, 221, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 221, 221, 3, 221, 3, 3, 3, 221, 221, 3, 221, 221, 221, 221, 221, 221, 221, 221, 221, 3, 3, 3, ], [3, 3, 3, 225, 225, 225, 225, 225, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 225, 225, 3, 225, 3, 3, 3, 225, 225, 3, 225, 225, 225, 225, 225, 225, 225, 225, 225, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 141, 141, 3, 141, 3, 3, 3, 141, 3, 3, 141, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 376, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 133, 3, 3, 3, 3, 3, 133, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 8, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 408, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 41, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 253, 253, 253, 253, 253, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 253, 253, 3, 253, 3, 3, 3, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 3, 3, 3, ], [3, 3, 3, 265, 265, 265, 265, 265, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 265, 265, 3, 265, 3, 3, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 265, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 440, 3, 285, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 261, 261, 261, 261, 261, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 261, 261, 3, 261, 3, 3, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 452, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 456, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 464, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 468, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 472, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 45, 3, 3, 45, 45, 3, 3, 3, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 3, 45, 3, 45, 45, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 45, 45, 45, ], [3, 3, 3, 3, 3, 24, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 476, ], [3, 3, 3, 3, 73, 73, 3, 3, 3, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 3, 73, 3, 73, 73, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 73, 73, 73, ], [3, 3, 3, 3, 53, 53, 3, 3, 3, 53, 53, 3, 53, 53, 53, 53, 53, 53, 53, 53, 53, 3, 53, 3, 53, 53, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 53, 53, 53, ], [3, 3, 3, 3, 57, 57, 3, 3, 3, 57, 57, 3, 57, 57, 57, 57, 57, 57, 57, 57, 57, 3, 57, 3, 57, 57, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 57, 57, 57, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 480, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 61, 61, 3, 3, 3, 61, 61, 3, 61, 61, 61, 61, 61, 61, 61, 61, 61, 3, 61, 3, 61, 61, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 61, 61, 61, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 117, 3, 3, 117, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 293, 293, 3, 3, 3, 293, 293, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 293, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 293, 293, 293, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 149, 149, 3, 149, 3, 3, 3, 149, 3, 3, 149, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 484, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 8, 3, 3, 3, 3, 3, 3, 3, 113, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 500, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 65, 65, 3, 3, 3, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 3, 65, 3, 65, 65, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 65, 65, 65, ], [3, 3, 3, 3, 69, 69, 3, 3, 3, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 3, 69, 3, 69, 69, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 69, 69, 69, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 129, 3, 3, 3, 3, 3, 129, 3, 3, 36, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 81, 81, 3, 3, 3, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 3, 81, 3, 81, 81, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 81, 81, 81, ], [3, 3, 3, 3, 77, 77, 3, 3, 3, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 3, 77, 3, 77, 77, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 77, 77, 77, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 508, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 512, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 113, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 520, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 524, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 113, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 536, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 105, 105, 3, 3, 3, 105, 105, 548, 105, 105, 105, 105, 105, 105, 105, 105, 105, 3, 105, 3, 105, 105, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 105, 105, 105, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 556, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 113, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 564, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 101, 101, 3, 3, 3, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 3, 101, 3, 101, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 101, 101, 101, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 85, 85, 3, 3, 3, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 3, 85, 3, 85, 85, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 85, 85, 85, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 68, 113, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 576, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 97, 97, 3, 3, 3, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 3, 97, 3, 97, 97, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 97, 97, 97, ], [3, 3, 3, 3, 109, 109, 3, 3, 3, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 3, 109, 3, 109, 109, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 109, 109, 109, ], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 580, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 52, 56, 3, 3, 3, 60, 64, 3, 3, 380, 384, 388, 392, 396, 400, 404, 113, 3, 68, 3, 252, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 72, 76, 80, ], [3, 3, 3, 3, 89, 89, 3, 3, 3, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 3, 89, 3, 89, 89, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 89, 89, 89, ], [3, 3, 3, 3, 93, 93, 3, 3, 3, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 3, 93, 3, 93, 93, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 93, 93, 93, ], ];
        static GOTO: [[u8; 27]; 148] = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 11, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 39, 30, 31, 0, 0, 0, ], [0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 69, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 25, 26, 27, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 73, 26, 27, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 27, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 27, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 77, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 103, 0, 0, 0, 104, 0, 105, 106, 0, 107, 108, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 23, 24, 25, 26, 27, 28, 72, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 115, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 123, 124, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 129, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 132, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 136, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 142, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 146, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 104, 0, 0, 147, 0, 107, 0, 0, 109, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ], ];
        let mut stk: Vec<(_, u8)> = vec![(StackItem::_Token(Token { kind: TokenKind::_Eps, piece: b"", line: 0, col: 0 }), 0)];
        let mut state = 0;
        let mut token = lexer.next();

        loop {
            let act = *index!(index!(ACTION, state), token.kind as usize) as usize;
            let act_val = act >> 2;
            match act & 3 {
                0 => {
                    stk.push((StackItem::_Token(token), act_val as _));
                    state = act_val;
                    token = lexer.next();
                }
                1 => {
                    let value = match act_val {
                        0 => {
                            let d: Declaration<'p> = match stk.pop() {
                                Some((StackItem::_9(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut prog: Prog<'p> = match stk.pop() {
                                Some((StackItem::_0(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_0({
                                {
                                    Prog
                                    { contents: (prog.contents.push(FuncDecl::Decl(d)), prog.contents).1 }
                                }
                            })
                        }
                        1 => {
                            let f: Func<'p> = match stk.pop() {
                                Some((StackItem::_2(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut prog: Prog<'p> = match stk.pop() {
                                Some((StackItem::_0(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_0({
                                {
                                    Prog
                                    { contents: (prog.contents.push(FuncDecl::Func(f)), prog.contents).1 }
                                }
                            })
                        }
                        2 => {
                            StackItem::_0({ { Prog { contents: vec![] } } })
                        }
                        3 => {
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_1({ { SCALAR } })
                        }
                        4 => {
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let t: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_1({ { Type { cnt: t.cnt + 1, dim: t.dim } } })
                        }
                        5 => {
                            let stmts: Vec<BlockItem<'p>> = match stk.pop() {
                                Some((StackItem::_4(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let params: Vec<Declaration<'p>> = match stk.pop() {
                                Some((StackItem::_3(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let name: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_2({ { Func { name: name.str(), params, stmts: Some(stmts), ret: typ } } })
                        }
                        6 => {
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let params: Vec<Declaration<'p>> = match stk.pop() {
                                Some((StackItem::_3(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let name: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_2({ { Func { name: name.str(), params, stmts: None, ret: typ } } })
                        }
                        7 => {
                            StackItem::_3({ { vec![] } })
                        }
                        8 => {
                            let name: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut fir: Vec<Declaration<'p>> = match stk.pop() {
                                Some((StackItem::_3(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_3({ { (fir.push(Declaration { name: name.str(), val: None, typ }), fir).1 } })
                        }
                        9 => {
                            StackItem::_3({ { vec![] } })
                        }
                        10 => {
                            let _comma: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let name: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut fir: Vec<Declaration<'p>> = match stk.pop() {
                                Some((StackItem::_3(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_3({ { (fir.push(Declaration { name: name.str(), val: None, typ }), fir).1 } })
                        }
                        11 => {
                            let _r: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let blk: Vec<BlockItem<'p>> = match stk.pop() {
                                Some((StackItem::_4(x), _)) => x,
                                _ => impossible!()
                            };
                            let _l: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_4({ { blk } })
                        }
                        12 => {
                            StackItem::_4({ { vec![] } })
                        }
                        13 => {
                            let r: BlockItem<'p> = match stk.pop() {
                                Some((StackItem::_5(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut stmts: Vec<BlockItem<'p>> = match stk.pop() {
                                Some((StackItem::_4(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_4({ { (stmts.push(r), stmts).1 } })
                        }
                        14 => {
                            let stmt: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_5({ { BlockItem::Stmt(stmt) } })
                        }
                        15 => {
                            let x: Declaration<'p> = match stk.pop() {
                                Some((StackItem::_9(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_5({ { BlockItem::Decl(x) } })
                        }
                        16 => {
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _break: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::Break } })
                        }
                        17 => {
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _continue: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::Continue } })
                        }
                        18 => {
                            let blk: Vec<BlockItem<'p>> = match stk.pop() {
                                Some((StackItem::_4(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::Compound(blk) } })
                        }
                        19 => {
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _r: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::Ret(e) } })
                        }
                        20 => {
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let m: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::MaybeExpr(m) } })
                        }
                        21 => {
                            let maybe_else: Option<Stmt<'p>> = match stk.pop() {
                                Some((StackItem::_7(x), _)) => x,
                                _ => impossible!()
                            };
                            let if_stmt: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let cond: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _if: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::If(cond, Box::new(if_stmt), add_box(maybe_else)) } })
                        }
                        22 => {
                            let body: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let update: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let cond: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            let decl: Declaration<'p> = match stk.pop() {
                                Some((StackItem::_9(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _for: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({
                                {
                                    Stmt::
                                    Compound(vec![BlockItem::Decl(decl), BlockItem::
                                    Stmt(Stmt::For(cond, Box::new(body), update))])
                                }
                            })
                        }
                        23 => {
                            let body: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let update: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let cond: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            let _s0: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let init: Option<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_8(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lpar: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _for: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({
                                {
                                    Stmt::
                                    Compound(vec![BlockItem::Stmt(Stmt::MaybeExpr(init)), BlockItem::
                                    Stmt(Stmt::For(cond, Box::new(body), update))])
                                }
                            })
                        }
                        24 => {
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let cond: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _while: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let body: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _do: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::DoWhile(Box::new(body), cond) } })
                        }
                        25 => {
                            let body: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let cond: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _while: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_6({ { Stmt::For(Some(cond), Box::new(body), None) } })
                        }
                        26 => {
                            StackItem::_7({ { None } })
                        }
                        27 => {
                            let stmt: Stmt<'p> = match stk.pop() {
                                Some((StackItem::_6(x), _)) => x,
                                _ => impossible!()
                            };
                            let _else: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_7({ { Some(stmt) } })
                        }
                        28 => {
                            StackItem::_8({ { None } })
                        }
                        29 => {
                            let x: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_8({ { Some(x) } })
                        }
                        30 => {
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let dim: Vec<usize> = match stk.pop() {
                                Some((StackItem::_10(x), _)) => x,
                                _ => impossible!()
                            };
                            let iden: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_9({
                                {
                                    Declaration
                                    { name: iden.str(), val: None, typ: Type { cnt: typ.cnt, dim } }
                                }
                            })
                        }
                        31 => {
                            let _s: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _e: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let iden: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_9({
                                {
                                    Declaration
                                    {
                                        name: iden.str(),
                                        val: Some(e),
                                        typ: Type
                                        { cnt: typ.cnt, dim: vec![] },
                                    }
                                }
                            })
                        }
                        32 => {
                            StackItem::_10({ { vec![] } })
                        }
                        33 => {
                            let _rb: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let x: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lb: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut d: Vec<usize> = match stk.pop() {
                                Some((StackItem::_10(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_10({ { (d.push(x.parse()), d).1 } })
                        }
                        34 => {
                            let cond: Conditional<'p> = match stk.pop() {
                                Some((StackItem::_12(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_11({ { Expr::Cond(cond) } })
                        }
                        35 => {
                            let c: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _b: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_11({ { Expr::Assign(u, Box::new(c)) } })
                        }
                        36 => {
                            let o: LogicalOr<'p> = match stk.pop() {
                                Some((StackItem::_13(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_12({ { Conditional::LOr(o) } })
                        }
                        37 => {
                            let false_cond: Conditional<'p> = match stk.pop() {
                                Some((StackItem::_12(x), _)) => x,
                                _ => impossible!()
                            };
                            let _c: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let true_exp: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _q: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let o: LogicalOr<'p> = match stk.pop() {
                                Some((StackItem::_13(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_12({ { Conditional::Cond(o, Box::new(true_exp), Box::new(false_cond)) } })
                        }
                        38 => {
                            let a: LogicalAnd<'p> = match stk.pop() {
                                Some((StackItem::_14(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_13({ { LogicalOr::LAnd(a) } })
                        }
                        39 => {
                            let b: LogicalAnd<'p> = match stk.pop() {
                                Some((StackItem::_14(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: LogicalOr<'p> = match stk.pop() {
                                Some((StackItem::_13(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_13({ { LogicalOr::Bop(Box::new(a), BinaryOp::LOr, b) } })
                        }
                        40 => {
                            let a: Equality<'p> = match stk.pop() {
                                Some((StackItem::_15(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_14({ { LogicalAnd::Eqn(a) } })
                        }
                        41 => {
                            let b: Equality<'p> = match stk.pop() {
                                Some((StackItem::_15(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: LogicalAnd<'p> = match stk.pop() {
                                Some((StackItem::_14(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_14({ { LogicalAnd::Bop(Box::new(a), BinaryOp::LAnd, b) } })
                        }
                        42 => {
                            let a: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_15({ { Equality::Rel(a) } })
                        }
                        43 => {
                            let b: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Equality<'p> = match stk.pop() {
                                Some((StackItem::_15(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_15({ { Equality::Bop(Box::new(a), BinaryOp::Eqt, b) } })
                        }
                        44 => {
                            let b: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Equality<'p> = match stk.pop() {
                                Some((StackItem::_15(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_15({ { Equality::Bop(Box::new(a), BinaryOp::Neq, b) } })
                        }
                        45 => {
                            let a: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_16({ { Relational::Add(a) } })
                        }
                        46 => {
                            let b: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_16({ { Relational::Bop(Box::new(a), BinaryOp::Geq, b) } })
                        }
                        47 => {
                            let b: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_16({ { Relational::Bop(Box::new(a), BinaryOp::Leq, b) } })
                        }
                        48 => {
                            let b: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_16({ { Relational::Bop(Box::new(a), BinaryOp::Gt, b) } })
                        }
                        49 => {
                            let b: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let a: Relational<'p> = match stk.pop() {
                                Some((StackItem::_16(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_16({ { Relational::Bop(Box::new(a), BinaryOp::Lt, b) } })
                        }
                        50 => {
                            let m: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_17({ { Additive::Mul(m) } })
                        }
                        51 => {
                            let mlt: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let adt: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_17({ { Additive::Bop(Box::new(adt), BinaryOp::Add, mlt) } })
                        }
                        52 => {
                            let mlt: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let adt: Additive<'p> = match stk.pop() {
                                Some((StackItem::_17(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_17({ { Additive::Bop(Box::new(adt), BinaryOp::Sub, mlt) } })
                        }
                        53 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_18({ { Multiplicative::U(u) } })
                        }
                        54 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let m: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_18({ { Multiplicative::Mul(Box::new(m), BinaryOp::Mul, u) } })
                        }
                        55 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let m: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_18({ { Multiplicative::Mul(Box::new(m), BinaryOp::Div, u) } })
                        }
                        56 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let m: Multiplicative<'p> = match stk.pop() {
                                Some((StackItem::_18(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_18({ { Multiplicative::Mul(Box::new(m), BinaryOp::Mod, u) } })
                        }
                        57 => {
                            let p: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { p } })
                        }
                        58 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Uop(UnaryOp::UNeg, Box::new(u)) } })
                        }
                        59 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Uop(UnaryOp::UNot, Box::new(u)) } })
                        }
                        60 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Uop(UnaryOp::UBNot, Box::new(u)) } })
                        }
                        61 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Uop(UnaryOp::Deref, Box::new(u)) } })
                        }
                        62 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Uop(UnaryOp::Ref, Box::new(u)) } })
                        }
                        63 => {
                            let u: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let typ: Type = match stk.pop() {
                                Some((StackItem::_1(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::ExplicitConversion(typ, Box::new(u)) } })
                        }
                        64 => {
                            let p: Primary<'p> = match stk.pop() {
                                Some((StackItem::_20(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Prim(p) } })
                        }
                        65 => {
                            let _rb: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lb: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let p: Unary<'p> = match stk.pop() {
                                Some((StackItem::_19(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Index(Box::new(p), Box::new(e)) } })
                        }
                        66 => {
                            let _rp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let exprlist: Vec<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_21(x), _)) => x,
                                _ => impossible!()
                            };
                            let _lp: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let name: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_19({ { Unary::Call(name.str(), exprlist) } })
                        }
                        67 => {
                            let i: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_20({ { Primary::Int(i.parse(), std::marker::PhantomData) } })
                        }
                        68 => {
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let _: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_20({ { Primary::Braced(Box::new(e)) } })
                        }
                        69 => {
                            let x: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_20({ { Primary::Identifier(x.str()) } })
                        }
                        70 => {
                            StackItem::_21({ { vec![] } })
                        }
                        71 => {
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut l: Vec<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_21(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_21({ { (l.push(e), l).1 } })
                        }
                        72 => {
                            StackItem::_21({ { vec![] } })
                        }
                        73 => {
                            let _com: Token = match stk.pop() {
                                Some((StackItem::_Token(x), _)) => x,
                                _ => impossible!()
                            };
                            let e: Expr<'p> = match stk.pop() {
                                Some((StackItem::_11(x), _)) => x,
                                _ => impossible!()
                            };
                            let mut l: Vec<Expr<'p>> = match stk.pop() {
                                Some((StackItem::_21(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_21({ { (l.push(e), l).1 } })
                        }
                        74 => {
                            let _1 = match stk.pop() {
                                Some((StackItem::_0(x), _)) => x,
                                _ => impossible!()
                            };
                            StackItem::_0({ _1 })
                        }

                        _ => impossible!(),
                    };
                    let nxt = *index!(index!(GOTO, index!(stk, stk.len() - 1).1 as usize), *index!(PROD, act_val) as usize);
                    stk.push((value, nxt));
                    state = nxt as usize;
                }
                2 => return Ok(match stk.pop() {
                    Some((StackItem::_0(r), _)) => r,
                    _ => impossible!()
                }),
                _ => return Err(token),
            }
        }
    }
}
